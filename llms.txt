# Zero Svelte (zero-svelte)

## What this library is
- Svelte 5 bindings for @rocicorp/zero (v0.25+), a local-first sync database
- Provides reactive Svelte wrappers so Zero queries automatically update components
- Main exports:
  - `Z` class: Wraps a Zero instance with Svelte reactivity
  - `Query` class: Materializes a Zero query into reactive `.data` and `.details`
  - `Connection` and `ConnectionState` types: For connection management

## When to use it
- Build Svelte 5 apps that are local-first, offline-capable, with optimistic updates and automatic sync via Zero

## Install
```bash
npm install zero-svelte
# Peers: Svelte 5+, @rocicorp/zero ^0.25
```

## Schema Setup (Zero 0.25 pattern)

```ts
// schema.ts
import { createBuilder, createSchema, defineQueries, defineQuery, table, string, boolean } from '@rocicorp/zero';
import { type } from 'arktype'; // or zod

const todos = table('todo')
  .columns({ id: string(), title: string(), completed: boolean() })
  .primaryKey('id');

export const schema = createSchema({ tables: [todos] });
export type Schema = typeof schema;

// Typed ZQL builder for raw queries
export const zql = createBuilder(schema);

// Reusable queries with validators
export const queries = defineQueries({
  todo: {
    all: defineQuery(() => zql.todo),
    byCompleted: defineQuery(
      type({ completed: 'boolean' }),
      ({ args: { completed } }) => zql.todo.where('completed', '=', completed)
    )
  }
});

// Register as default type (removes need for explicit generics)
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    schema: Schema;
  }
}
```

## Z Instance Setup

```ts
// zero.svelte.ts
import { Z } from 'zero-svelte';
import { schema } from './schema';
import { mutators } from './mutators';

export const z = new Z({
  cacheURL: 'http://localhost:4848',
  schema,
  mutators,
  userID: 'anon',
  kvStore: 'mem'
});

export { mutators };
```

## Disable SSR
```ts
// +page.ts or +layout.ts
export const ssr = false;
```

## Using Queries

### Basic query with defineQuery
```svelte
<script lang="ts">
  import { z } from '$lib/zero.svelte';
  import { queries } from './schema';

  const todos = z.createQuery(queries.todo.all());
</script>

{#each todos.data as todo (todo.id)}
  <div>{todo.title}</div>
{/each}
```

### Reactive queries with $derived
```svelte
<script lang="ts">
  let showCompleted = $state(false);

  // Recreates query when showCompleted changes
  const filtered = $derived(z.createQuery(queries.todo.byCompleted({ completed: showCompleted })));
</script>
```

### Raw ZQL for local-only filtering (no server round-trip)
```svelte
<script lang="ts">
  import { zql } from './schema';

  let search = $state('');

  const results = $derived.by(() => {
    let q = zql.todo;
    if (search) q = q.where('title', 'ILIKE', `%${search}%`);
    return z.createQuery(q);
  });
</script>
```

### Query with enabled flag
```ts
// Won't materialize until enabled is true
const todos = z.createQuery(queries.todo.all(), false);
```

### Updating a query in place
```ts
const todos = z.createQuery(zql.todo);
// Later:
todos.updateQuery(zql.todo.where('completed', '=', true));
```

## Query API
- `query.data` - The reactive query results (array or single object)
- `query.details` - Status object with `.type`: 'unknown' | 'complete'
- `query.updateQuery(newQuery, enabled?)` - Update query definition in place
- `query.destroy()` - Clean up subscriptions

## Mutations

Use Zero's mutator pattern:
```ts
import { z, mutators } from '$lib/zero.svelte';

// Insert
z.mutate(mutators.todo.insert({ id: '1', title: 'New', completed: false }));

// Update
z.mutate(mutators.todo.update({ id: '1', completed: true }));

// Delete
z.mutate(mutators.todo.delete({ id: '1' }));
```

## Connection State (Zero 0.25+)

Analogous to React's `useConnectionState()` hook:

```svelte
<script lang="ts">
  import { z } from '$lib/zero.svelte';
</script>

{#if z.connectionState.name === 'connected'}
  <span>Connected</span>
{:else if z.connectionState.name === 'connecting'}
  <span>Connecting...</span>
{:else if z.connectionState.name === 'disconnected'}
  <span>Offline: {z.connectionState.reason}</span>
{:else if z.connectionState.name === 'needs-auth'}
  <button onclick={() => z.connection.connect({ auth: newToken })}>Re-authenticate</button>
{:else if z.connectionState.name === 'error'}
  <button onclick={() => z.connection.connect()}>Retry</button>
{/if}
```

### Connection states
- `connecting` - Actively trying to connect
- `connected` - Successfully connected
- `disconnected` - Offline, auto-retrying
- `needs-auth` - Auth failed, call `z.connection.connect({ auth })` with new token
- `error` - Fatal error, call `z.connection.connect()` to retry
- `closed` - Instance closed, create new Z

## Z Class API

### Properties
- `z.query` - Zero's query builders (e.g., `z.query.todo`)
- `z.mutate` - Execute mutations
- `z.mutateBatch` - Batch multiple mutations
- `z.connectionState` - Current connection state (reactive)
- `z.connection` - Connection API with `.connect()` method
- `z.clientID` - Unique client identifier
- `z.userID` - Current user ID
- `z.viewStore` - Internal view management
- `z.online` - _(deprecated)_ Use `connectionState` instead
- `z.current` - _(deprecated)_ Direct Zero instance access

### Methods
- `z.createQuery(query, enabled?)` - Create a reactive Query
- `z.q(query, enabled?)` - Alias for createQuery
- `z.preload(query, options?)` - Preload data into cache
- `z.run(query, options?)` - Execute query once (returns Promise)
- `z.materialize(query)` - Create a TypedView directly
- `z.build(options)` - Rebuild Zero instance (for auth changes)
- `z.close()` - Close and cleanup

## Lifecycle

```ts
// Rebuild when auth changes
z.build({ ...options, auth: newToken });

// Clean up when done
z.close();
```

## Key Implementation Details
- Client-only: SSR must be disabled
- Views are shared by query hash to avoid redundant materialization
- Uses Svelte 5 runes ($state, $derived, $effect) for reactivity
- Query subscriptions are lazy - only materialize when `.data` is accessed

## Links
- Zero docs: https://zero.rocicorp.dev/docs/introduction
- Connection state: https://zero.rocicorp.dev/docs/connection
